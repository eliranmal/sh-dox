#!/usr/bin/env bash


show_help_renderer() {
	printf "
usage:

$(t_code_block \
"sh" \
"( export FORMAT=<format> [OUTPUT_PATH=<output_path>] ; my-command -h | ./renderer )"
)


$(t_heading "renderer" | t_fg_red)

the $(t_fg_yellow "styli.sh") renderer.


$(t_subheading "flags")

$(t_code_definition \
"-h" \
"shows this help message.")


$(t_subheading "environment")

environment variables for the renderer must be declared using $(t_code 'export') \
(rather than $(t_code 'env')), in order to share them both with the renderer and the formatter in your program.

$(t_code_definition \
"FORMAT" \
"which format to use. possible values: $(t_code 'markdown'), $(t_code 'terminal'), $(t_code 'raw').")

$(t_code_definition \
"OUTPUT_PATH" \
"where to write to. defaults to $(t_code '<working-dir>/output/<cmd>.<ext>'), \
where $(t_code '<cmd>') is the command name that's piped to the renderer, \
and $(t_code '<ext>') is a file extension resolved from the passed format.")

$(t_list_item \
"")


$(t_subheading "what it does")

the renderer's job is to read the formatted output of a program, and write it to a file.


$(t_subheading "examples")

$(t_list_item \
"auto resolve the output path" \
"
$(t_code_block \
"sh" \
'( export FORMAT="markdown" ; ./foo -h | ./styli.sh/renderer )')

writes to $(t_code './output/foo.md')")

$(t_list_item \
"be explicit about everything" \
"
$(t_code_block \
"sh" \
'( export FORMAT="markdown" OUTPUT_PATH='./usage/bar.md' ; ./foo -h | ./styli.sh/renderer )')

writes to $(t_code './usage/bar.md')")


"
	exit 0
}


init_renderer() {

	echo "> > > rendering output to a file"

	local output_path=$(resolve_output_path)
	echo "> output path: '$output_path'"

	ensure_dir "$( dirname "$output_path" )"

	echo "> redirecting all output to the output path"
	# test if this script is executed (i.e. not sourced)
	if [[ $BASH_SOURCE = $0 ]]; then
		echo "$(cat -)" | strip_down | dress_up > ${output_path}
	else
		exec 1> ${output_path} > >( strip_down | dress_up )
	fi
}

ensure_dir() {
	if [[ ! -d $1 ]]; then
		mkdir -p "$1"
	fi
}

resolve_output_path() {

	local output_path
	if [[ -n $OUTPUT_PATH ]]; then
		output_path="$OUTPUT_PATH"
	else
		local working_dir=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")
		local output_dir="$working_dir/output"
		# default file name is the executed command
		local output_file_name="$(basename $0)"
		local output_file_ext
		case $FORMAT in
			markdown)
				output_file_ext="md"
				;;
			*) # raw/terminal formats will be written to plain text files
				output_file_ext="txt"
				;;
		esac
		output_path="$output_dir"'/'"$output_file_name"'.'"$output_file_ext"
	fi

	printf "%s" "$output_path"
}

dress_up() {
    add_message | eof
}

strip_down() {
	case $FORMAT in
		markdown)
			squeeze_blanks
			;;
		*)
			printf "$(cat -)"
			;;
	esac
}

add_message() {
	local repo_url="https://github.com/eliranmal/styli.sh"
	case $FORMAT in
		markdown)
			printf "%s\n\n\n\n%s\n%s\n%s" "$(cat -)" '<br/><br/>' '---' \
			'<sup><i>created with <b><a href="'"$repo_url"'">styli.sh</a></b></i></sup>'
			;;
		raw)
			printf "%s\n\n\n\n\n%s\n%s" "$(cat -)" '---' 'created with styli.sh ('"$repo_url"')'
			;;
		*)
			printf "$(cat -)"
			;;
	esac
}

eof() {
	case $FORMAT in
		markdown)
			echo "$(cat -)" # add newline at end of file
			;;
		*)
			printf "$(cat -)"
			;;
	esac
}

squeeze_blanks() {
	cat -s
}


main() {

	# test if this script is executed (i.e. not sourced)
	if [[ $BASH_SOURCE = $0 ]]; then
		if [[ $1 = "-h" ]]; then
			local source_dir="$( cd "$(dirname "${BASH_SOURCE}")" ; pwd -P )"
			source "$source_dir"/formatter
			show_help_renderer
		fi
		init_renderer
	fi
}

main "$@"
