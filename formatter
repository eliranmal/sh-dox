#!/usr/bin/env bash


show_help_formatter() {
	printf "
$(t_heading "formatter" | t_fg_yellow)

utilities for shell output formatting.


$(t_subheading "usage")

$(t_code_block \
"sh" \
'[env FORMAT=terminal|markdown|raw ;] source ./formatter')

$(t_code_block \
"sh" \
'./formatter -h')


$(t_subheading "flags")

$(t_code_definition \
"-h" \
"shows this help message.")


$(t_subheading "how to use")
 
two possible ways:

$(t_list_item \
"include the available $(t_code '_t_*') tags within strings to wrap terms.
tags must be closed with the appropriate $(t_code '_t_*_off') tag.")
$(t_list_item \
"use the formatter functions, they can be piped, or accept arguments.")


$(t_subheading "examples")

$(t_list_item \
"wrapping with tags" \
"
$(t_code_block \
"sh" \
'echo "${_t_bold}this text will be bold${_t_bold_off}"
echo "text can be ${_t_under}underlined${_t_under_off} as well"
echo "color me ${_t_fg_yellow}yellow${_t_fg_off}"')")

$(t_list_item \
"using functions" \
"
$(t_code_block \
"sh" \
'echo "$(t_heading "foo")"
echo "$(echo "foo" | t_heading)"
echo "$(echo "foo" | t_heading | t_fg_yellow)"')

you can also skip the echo, and compose most of the formatter functions in any which way:

$(t_code_block \
"sh" \
'echo "$(t_heading "foo" | t_fg_yellow)"')
$(t_if "terminal" "
$(t_output \
"$(t_heading "yellow heading" | t_fg_yellow)")")

$(t_code_block \
"sh" \
'echo "$(t_fg_yellow "foo" | t_bold | t_under)"')
$(t_if "terminal" "
$(t_output \
"$(t_fg_yellow "yellow bold underlined" | t_bold | t_under)")")

some formatter functions cannot be composed, but can still be used regardless:

$(t_code_block \
"sh" \
'echo "$(t_fg_rainbow "the quick brown fox jumps over the lazy dog")"')
$(t_if "terminal" "
$(t_output \
"$(t_fg_rainbow "the quick brown fox jumps over the lazy dog")")")")

$(t_subheading "gotcha's")

$(t_list_item \
"nesting formats may not behave as expected with the $(t_code 'terminal') format, \
as some closing tags reset all formatting.")
$(t_list_item \
"heavy use of formatter functions will impact performance, so use them wisely.")


$(t_subheading "references")

$(t_list_item \
"the colors used here are based on the $(t_link "SMYCK color scheme" 'http://color.smyck.org/').")
$(t_list_item \
"the hex color values from SMYCK were converted to their xterm-256 ansi approximations with $(t_link "colortrans.py" 'https://gist.github.com/MicahElliott/719710').")

"
	exit 0
}


# parses function input from stdin or passed arguments
# usage:
# local input=$(util_input "$@")
util_input() {
	local input
	if [ -t 0 ]; then
		if [ $# -gt 0 ]; then
			input="$*"
		fi
	else
		input=$(cat -)
	fi
	printf "%s" "$input"
}

util_resolve_format() {
	local format
	if type "init_api_${FORMAT}" >/dev/null 2>&1; then
		format="$FORMAT"
	else
		format="terminal"
	fi
	printf "%s" "$format"
}

util_switch() {
	local match_format="$1"; shift
	local format=$(util_resolve_format)
	local output
	if [[ $format = $match_format ]]; then
		output=$(util_input "$@")
	fi
	printf "%s" "$output"
}

util_fg_rainbow() {
	local colors=('red' 'yellow' 'green' 'cyan' 'blue' 'magenta')
	local input=$(util_input "$@")
	local chars="$(printf "%s" "$input" | grep -o . --color=never)"
	local i=0
	while read -r; do
		let "pos = $i % ${#colors[@]}"
		let "i++"
		local color="${colors[$pos]}"
		local var_name="_t_fg_$color"
		printf "${!var_name}$REPLY${_t_fg_off}"
	done <<< "$chars"
}

util_trim_start() {
	local input=$(util_input "$@")
	printf "%s" "$input" | sed -e '1s,[[:space:]][[:space:]]*\(.*\),\1,'
}

util_repeat() {
	local str=""
	for (( n=$2; n > 0; n-- )); do
		str="$str$1"
	done
	printf "%s" "$str"	
}

util_wrap() {
	local tag="$1"; shift; local tagoff="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s%s" "$tag" "$input" "$tagoff"
}

util_prefix() {
	local prefix="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s" "$prefix" "$input"
}

util_suffix() {
	local suffix="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s" "$input" "$suffix"
}

util_prefix_multiline() {
	local prefix=$1; shift
	local input=$(util_input "$@")
	printf "$input" | sed -e 's,^\(.*\)$,'"$prefix"'\1,'
}

util_suffix_multiline() {
	local suffix=$1; shift
	local input=$(util_input "$@")
	printf "$input" | sed -e 's,^\(.*\)$,\1'"$suffix"','
}

util_underline() {
	local char="$1"; shift
	local suffix="$1"; shift
	local input=$(util_input "$@")
	local underline="$(util_repeat ${char} ${#input})"
	printf "%s%s\n%s" "$input" "$suffix" "$underline"
}

util_replace_tags() {
	local from_tag="$1"; local from_tag_off="$2"; local to_tag="$3"; local to_tag_off="$4";
	sed -e 's,'"$from_tag"'\([^'"$from_tag"']*\)'"$from_tag_off"','"$to_tag"'\1'"$to_tag_off"',g'
}

util_escape_entities() {
	sed -e 's,\&,\&amp;,g' | sed -e 's,\<,\&lt;,g' | sed -e 's,\>,\&gt;,g'
}


init_api_terminal() {

	[[ -t 1 && -t 2 ]] && {
	
		_t_off=$(           tput sgr0                   )

		_t_bold=$(          tput bold   || tput md      )
		_t_bold_off=$_t_off
		_t_italic=$(        tput sitm   || tput ZH      )
		_t_italic_off=$(    tput ritm   || tput ZR      )
		_t_under=$(         tput smul   || tput us      )
		_t_under_off=$(     tput rmul   || tput ue      )
		
		local tput_colors=$(tput colors)
		if [[ $tput_colors ]]; then
			# `tput setaf 0 || tput AF 0` cannot be used to reset the foreground, as some 
			# terminal emulators (e.g. iterm2) will set it to explicit black. 
			# too bad, nesting tags in terminal mode may misbehave as a consequence.
			_t_fg_off=$_t_off
			if (( $tput_colors >= 256 )); then
				_t_fg_red=$(             tput setaf 167     || tput AF 167  )
				_t_fg_green=$(           tput setaf 107     || tput AF 107  )
				_t_fg_yellow=$(          tput setaf 179     || tput AF 179  )
				_t_fg_blue=$(            tput setaf 74      || tput AF 74   )
				_t_fg_magenta=$(         tput setaf 182     || tput AF 182  )
				_t_fg_cyan=$(            tput setaf 30      || tput AF 30   )
				_t_fg_lightred=$(        tput setaf 174     || tput AF 174  )
				_t_fg_lightgreen=$(      tput setaf 191     || tput AF 191  )
				_t_fg_lightyellow=$(     tput setaf 222     || tput AF 222  )
				_t_fg_lightblue=$(       tput setaf 153     || tput AF 153  )
				_t_fg_lightmagenta=$(    tput setaf 219     || tput AF 219  )
				_t_fg_lightcyan=$(       tput setaf 116     || tput AF 116  )
			elif (( $tput_colors >= 8 )); then
				_t_fg_red=$(             tput setaf 1       || tput AF 1    )
				_t_fg_green=$(           tput setaf 2       || tput AF 2    )
				_t_fg_yellow=$(          tput setaf 3       || tput AF 3    )
				_t_fg_blue=$(            tput setaf 4       || tput AF 4    )
				_t_fg_magenta=$(         tput setaf 5       || tput AF 5    )
				_t_fg_cyan=$(            tput setaf 6       || tput AF 6    )
				_t_fg_lightred=$_t_fg_red
				_t_fg_lightgreen=$_t_fg_green
				_t_fg_lightyellow=$_t_fg_yellow
				_t_fg_lightblue=$_t_fg_blue
				_t_fg_lightmagenta=$_t_fg_magenta
				_t_fg_lightcyan=$_t_fg_cyan
			fi
		fi

	} 2>/dev/null ||: # protect from "unknown terminfo capability" errors

	_t_strike=$'\033[9m'
	_t_strike_off=$'\033[29m'
	_t_code=$_t_bold
	_t_code_off=$_t_bold_off
	_t_list_item=' - '
	_t_new_line='
'

	t_heading() {
		util_underline '-' "$_t_fg_off" "$@" | util_wrap "$_t_bold" "$_t_bold_off"
	}
	t_subheading() {
		util_wrap "$_t_under" "$_t_under_off" "$@"
	}
	t_list_item() {
		local title; local body
		if [[ -n $2 ]]; then
			title="$1"; shift
		fi
		body="$(util_prefix_multiline '   ' "$1$_t_new_line")"
		if [[ -n $title ]]; then
			util_prefix "$(util_wrap "$_t_list_item$_t_under" "$_t_under_off" "$title")" "$_t_new_line$body"
		else
			util_trim_start "$body" | util_prefix "$_t_list_item"
		fi
	}
	t_definition() {
		local term="$1"
		local desc="$2"
		util_prefix '   ' "$term" | util_wrap "$_t_bold" "$_t_bold_off$_t_new_line"
		util_prefix_multiline '      ' "$desc$_t_new_line"
	}
	t_code_definition() {
		t_definition "$@"
	}
	t_code_block() {
		if [[ -n $2 ]]; then
			shift # ignore the first arg if there are more than one, it's the language specifier
		fi
		local body="$1"
		util_wrap "$_t_code" "$_t_code_off" "$body" | util_prefix_multiline '    '
	}
	t_link() {
		local name; local target
		if [[ -n $2 ]]; then
			name="$1"; shift
		fi
		target="$1"
		if [[ -n $name ]]; then
			printf "%s [%s]" "$name" "$target" | util_wrap "$_t_italic" "$_t_italic_off"
		else
			util_wrap "$_t_italic" "$_t_italic_off" "$target"
		fi
	}
	t_output() {
		util_prefix_multiline ' -> ' "$@"
	}

}

init_api_markdown() {
	
	_t_bold='**'
	_t_bold_off=$_t_bold
	_t_italic='_'
	_t_italic_off=$_t_italic
	_t_strike='~~'
	_t_strike_off=$_t_strike
	_t_code='`'
	_t_code_off=$_t_code
	_t_code_block='```'
	_t_code_block_off=$_t_code_block
	_t_list_item='- '
	_t_def_term='<dl>
	<dt>'
	_t_def_term_off='</dt>
'
	_t_def_desc='	<dd>'
	_t_def_desc_off='</dd>
</dl>
'
	_t_new_line="\n"
	_t_line_break="  $_t_new_line"

	t_heading() {
		util_prefix '## ' "$1"
	}
	t_subheading() {
		util_prefix '### ' "$1"
	}
	t_list_item() {
		local title; local body
		if [[ -n $2 ]]; then
			title="$1"; shift
		fi
		body="$(util_prefix_multiline '  ' "$1$_t_new_line")"
		if [[ -n $title ]]; then
			util_prefix "$(util_wrap "$_t_list_item$_t_bold" "$_t_bold_off" "$title")" "$_t_new_line$body"
		else
			util_trim_start "$body" | util_prefix "$_t_list_item"
		fi
	}
	t_definition() {
		local term="$(echo "$1" | util_escape_entities)"
		local desc="$(echo "$2" | util_escape_entities | util_suffix_multiline '<br/>')"
		util_wrap "$_t_def_term" "$_t_def_term_off" "$term" | util_replace_tags "$_t_code" "$_t_code_off" '<code>' '</code>'
		util_wrap "$_t_def_desc" "$_t_def_desc_off" "$desc" | util_replace_tags "$_t_code" "$_t_code_off" '<code>' '</code>'
	}
	t_code_definition() {
		local title="$(util_wrap "$_t_code" "$_t_code_off" "$1")"
		t_definition "$title" "$2"
	}
	t_code_block() {
		local lang
		if [[ -n $2 ]]; then
			lang="$1"; shift
		fi
		local body="$1"
		util_wrap "$_t_code_block$lang$_t_new_line" "$_t_new_line$_t_code_block_off" "$body"
	}
	t_link() {
		local name; local target
		if [[ -n $2 ]]; then
			name="$1"; shift
		fi
		target="$1"
		if [[ -n $name ]]; then
			printf "[%s](%s)" "$name" "$target"
		else
			printf "%s" "$target"
		fi
	}
	t_output() {
		t_code_block
	}

}

init_api_raw() {
# todo - stubs
	return 0
}

init_api_composeable() {

	t_bold() {              util_wrap     "$_t_bold"              "$_t_bold_off"    "$@"; }
	t_italic() {            util_wrap     "$_t_italic"            "$_t_italic_off"  "$@"; }
	t_strike() {            util_wrap     "$_t_strike"            "$_t_strike_off"  "$@"; }
	t_code() {              util_wrap     "$_t_code"              "$_t_code_off"    "$@"; }
	t_under() {             util_wrap     "$_t_under"             "$_t_under_off"   "$@"; }

	t_fg_red() {            util_wrap     "$_t_fg_red"            "$_t_fg_off"      "$@"; }
	t_fg_green() {          util_wrap     "$_t_fg_green"          "$_t_fg_off"      "$@"; }
	t_fg_yellow() {         util_wrap     "$_t_fg_yellow"         "$_t_fg_off"      "$@"; }
	t_fg_blue() {           util_wrap     "$_t_fg_blue"           "$_t_fg_off"      "$@"; }
	t_fg_magenta() {        util_wrap     "$_t_fg_magenta"        "$_t_fg_off"      "$@"; }
	t_fg_cyan() {           util_wrap     "$_t_fg_cyan"           "$_t_fg_off"      "$@"; }
	t_fg_lightred() {       util_wrap     "$_t_fg_lightred"       "$_t_fg_off"      "$@"; }
	t_fg_lightgreen() {     util_wrap     "$_t_fg_lightgreen"     "$_t_fg_off"      "$@"; }
	t_fg_lightyellow() {    util_wrap     "$_t_fg_lightyellow"    "$_t_fg_off"      "$@"; }
	t_fg_lightblue() {      util_wrap     "$_t_fg_lightblue"      "$_t_fg_off"      "$@"; }
	t_fg_lightmagenta() {   util_wrap     "$_t_fg_lightmagenta"   "$_t_fg_off"      "$@"; }
	t_fg_lightcyan() {      util_wrap     "$_t_fg_lightcyan"      "$_t_fg_off"      "$@"; }

}

init_api_common() {

	t_fg_rainbow() {        util_fg_rainbow         "$@"; }
	t_if() {                util_switch             "$@"; }

}

init_formatter() {
	local format=$(util_resolve_format)
	init_api_${format}
	init_api_common
	init_api_composeable
}


main() {

	init_formatter

	# test if this script is executed (i.e. not sourced)
	if [[ $BASH_SOURCE = $0 && $1 = "-h" ]]; then
		show_help_formatter
	fi
}

main "$@"
