#!/usr/bin/env bash


# 
# little text formatters for terminal or markdown style output.
# 
# 
# environment:
#   [FORMAT=terminal|markdown]
# 
# 
# usage:
# 
# two possible ways:
# 
# - include the available _t_* tags within strings to wrap terms.
#   tags must be closed with the appropriate _t_*_off tag.
# 
# - use the formatter functions, they can be piped, or accept arguments.
# 
# 
# examples:
# 
# - wrapping with tags:
#   echo "this text will be ${_t_bold}bold${_t_bold_off}"
#   echo "text can be ${_t_under}underlined${_t_under_off} as well"
#   echo "color text in ${_t_fg_yellow}yellow${_t_fg_off} or ${_t_fg_blue}blue${_t_fg_off}"
# 
# - using functions:
# 
#       echo "$(t_heading "foo")"
#       echo "$(echo "foo" | t_heading)"
#       echo "$(echo "foo" | t_heading | t_fg_yellow)"
# 
#   you can also skip the echo, and compose the formatter functions in any which way:
# 
#       echo "$(t_heading "foo" | t_fg_yellow)"
# 
# 
# gotcha's:
# 
# - nesting formats may not behave as expected in the terminal mode, as some 
# closing tags reset all formatting.
# 
# 
# references:
# 
# - the colors used here are based on the SMYCK color scheme (http://color.smyck.org/):
# 
#   red: #c75646
#   green: #8eb33b
#   yellow: #d0b03c
#   blue: #72b3cc
#   magenta: #c8a0d1
#   cyan: #218693
#   lightred: #e09690
#   lightgreen: #cdee69
#   lightyellow: #ffe377
#   lightblue: #9cd9f0
#   lightmagenta: #fbb1f9
#   lightcyan: #77dfd8
# 
#   they were converted to their xterm-256 ansi equivalents with colortrans.py 
#   (https://gist.github.com/MicahElliott/719710).
# 



# parses function input from stdin or passed arguments
# usage:
# local input=$(util_input "$@")
util_input() {
	local input
	if [ -t 0 ]; then
		if [ $# -gt 0 ]; then
			input="$*"
		fi
	else
		input=$(cat -)
	fi
	printf "%s" "$input"
}

util_fg_rainbow() {
	local colors=('red' 'yellow' 'green' 'cyan' 'blue' 'magenta')
	local input=$(util_input "$@")
	local chars="$(printf "%s" "$input" | grep -o . --color=never)"
	local i=0
	while read -r; do
		let "pos = $i % ${#colors[@]}"
		let "i++"
		local color="${colors[$pos]}"
		local var_name="_t_fg_$color"
		printf "${!var_name}$REPLY${_t_fg_off}"
	done <<< "$chars"
}

util_repeat() {
    seq -f "$1" -s '' $2
}

util_wrap() {
	local tag="$1"; shift; local tagoff="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s%s" "$tag" "$input" "$tagoff"
}

util_prefix() {
	local prefix="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s" "$prefix" "$input"
}

util_suffix() {
	local suffix="$1"; shift
	local input=$(util_input "$@")
	printf "%s%s" "$input" "$suffix"
}

util_prefix_multiline() {
	local prefix=$1; shift
	local input=$(util_input "$@")
	printf "%s" "$input" | sed -e 's,^\(.*\)$,'"$prefix"'\1,'
}

util_suffix_multiline() {
	local suffix=$1; shift
	local input=$(util_input "$@")
	printf "%s" "$input" | sed -e 's,^\(.*\)$,\1'"$suffix"','
}

util_underline() {
	local char="$1"; shift
	local suffix="$1"; shift
	local input=$(util_input "$@")
	local underline="$(util_repeat ${char} ${#input})"
	printf "%s%s\n%s" "$input" "$suffix" "$underline"
}

util_replace_tags() {
	local from_tag="$1"; local from_tag_off="$2"; local to_tag="$3"; local to_tag_off="$4";
	sed -e 's,'"$from_tag"'\([^'"$from_tag"']*\)'"$from_tag_off"','"$to_tag"'\1'"$to_tag_off"',g'
}

util_replace_entities() {
	sed -e 's,\&,\&amp;,g' | sed -e 's,\<,\&lt;,g' | sed -e 's,\>,\&gt;,g'
}


init_api_terminal() {

	[[ -t 1 && -t 2 ]] && {
	
		_t_off=$(           tput sgr0                   )

		_t_bold=$(          tput bold   || tput md      )
		_t_bold_off=$_t_off
		_t_italic=$(        tput sitm   || tput ZH      )
		_t_italic_off=$(    tput ritm   || tput ZR      )
		_t_under=$(         tput smul   || tput us      )
		_t_under_off=$(     tput rmul   || tput ue      )
		
		local tput_colors=$(tput colors)
		if [[ $tput_colors ]]; then
			# `tput setaf 0 || tput AF 0` cannot be used to reset the foreground, as some 
			# terminal emulators (e.g. iterm2) will set it to explicit black. 
			# too bad, nesting tags in terminal mode may misbehave as a consequence.
			_t_fg_off=$_t_off
			if (( $tput_colors >= 256 )); then
				_t_fg_red=$(             tput setaf 167     || tput AF 167  )
				_t_fg_green=$(           tput setaf 107     || tput AF 107  )
				_t_fg_yellow=$(          tput setaf 179     || tput AF 179  )
				_t_fg_blue=$(            tput setaf 74      || tput AF 74   )
				_t_fg_magenta=$(         tput setaf 182     || tput AF 182  )
				_t_fg_cyan=$(            tput setaf 30      || tput AF 30   )
				_t_fg_lightred=$(        tput setaf 174     || tput AF 174  )
				_t_fg_lightgreen=$(      tput setaf 191     || tput AF 191  )
				_t_fg_lightyellow=$(     tput setaf 222     || tput AF 222  )
				_t_fg_lightblue=$(       tput setaf 153     || tput AF 153  )
				_t_fg_lightmagenta=$(    tput setaf 219     || tput AF 219  )
				_t_fg_lightcyan=$(       tput setaf 116     || tput AF 116  )
			elif (( $tput_colors >= 8 )); then
				_t_fg_red=$(             tput setaf 1       || tput AF 1    )
				_t_fg_green=$(           tput setaf 2       || tput AF 2    )
				_t_fg_yellow=$(          tput setaf 3       || tput AF 3    )
				_t_fg_blue=$(            tput setaf 4       || tput AF 4    )
				_t_fg_magenta=$(         tput setaf 5       || tput AF 5    )
				_t_fg_cyan=$(            tput setaf 6       || tput AF 6    )
				_t_fg_lightred=$_t_fg_red
				_t_fg_lightgreen=$_t_fg_green
				_t_fg_lightyellow=$_t_fg_yellow
				_t_fg_lightblue=$_t_fg_blue
				_t_fg_lightmagenta=$_t_fg_magenta
				_t_fg_lightcyan=$_t_fg_cyan
			fi
		fi

	} 2>/dev/null ||: # protect from "unknown terminfo capability" errors

	_t_strike=$'\033[9m'
	_t_strike_off=$'\033[29m'
	_t_code=$_t_bold
	_t_code_off=$_t_bold_off
	_t_list_item=' * '
	_t_new_line='
'
	_t_line_break=$_t_new_line
	_t_blank_line="$_t_new_line "

	t_heading() {
		util_underline '-' "$_t_fg_off" "$@" | util_wrap "$_t_bold" "$_t_bold_off"
	}
	t_subheading() {
		util_wrap "$_t_under" "$_t_under_off" "$@"
	}
	t_list_item() {
		local title="$1"
		local body="$2"
		if [[ -z $body ]]; then
			util_prefix "$_t_list_item" "$title$_t_new_line"
		else
			util_wrap "$_t_bold$_t_list_item" "$_t_bold_off$_t_line_break" "$title"
			util_prefix_multiline '      ' "$body$_t_blank_line"
		fi
	}
	t_definition() {
		local term="$1"
		local desc="$2"
		util_prefix '   ' "$term" | util_wrap "$_t_bold" "$_t_bold_off$_t_new_line"
		util_prefix_multiline '      ' "$desc$_t_blank_line"
	}
	t_code_definition() {
		t_definition "$@"
	}
	t_code_block() {
		util_wrap "$_t_new_line" "$_t_new_line$_t_new_line" "$@" | util_prefix_multiline
	}

}

init_api_markdown() {
	
	_t_bold='**'
	_t_bold_off=$_t_bold
	_t_italic='_'
	_t_italic_off=$_t_italic
	_t_strike='~~'
	_t_strike_off=$_t_strike
	_t_code='`'
	_t_code_off=$_t_code
	_t_list_item='- '
	_t_def_term='<dl>
	<dt>'
	_t_def_term_off='</dt>
'
	_t_def_desc='	<dd>'
	_t_def_desc_off='</dd>
</dl>
'
	_t_new_line='
'
	_t_line_break="  $_t_new_line"
	_t_blank_line="\n"

	t_heading() {
		util_prefix '## ' "$1"
	}
	t_subheading() {
		util_prefix '#### ' "$1"
	}
	t_list_item() {
		local title="$1"
		local body="$2"
		if [[ -z $body ]]; then
			util_prefix "$_t_list_item" "$title$_t_new_line"
		else
			util_wrap "$_t_list_item$_t_bold" "$_t_bold_off$_t_line_break" "$title"
			util_prefix_multiline '  ' "$body$_t_blank_line"
		fi
	}
	t_definition() {
		local term="$(echo "$1" | util_replace_entities)"
		local desc="$(echo "$2" | util_replace_entities | util_suffix_multiline '<br/>')"
		util_wrap "$_t_def_term" "$_t_def_term_off" "$term" | util_replace_tags "$_t_code" "$_t_code_off" '<code>' '</code>'
		util_wrap "$_t_def_desc" "$_t_def_desc_off" "$desc" | util_replace_tags "$_t_code" "$_t_code_off" '<code>' '</code>'
	}
	t_code_definition() {
		local title="$(util_wrap "$_t_code" "$_t_code_off" "$1")"
		t_definition "$title" "$2"
	}
	t_code_block() {
		util_wrap "$_t_new_line" "$_t_new_line$_t_new_line" "$@" | util_prefix_multiline
	}

}

init_api_raw() {
	return 0
}

init_api_composeable() {

	t_bold() {              util_wrap     "$_t_bold"              "$_t_bold_off"      "$@"; }
	t_italic() {            util_wrap     "$_t_italic"            "$_t_italic_off"    "$@"; }
	t_strike() {            util_wrap     "$_t_strike"            "$_t_strike_off"    "$@"; }
	t_code() {              util_wrap     "$_t_code"              "$_t_code_off"      "$@"; }
	t_under() {             util_wrap     "$_t_under"             "$_t_under_off"     "$@"; }

	t_fg_red() {            util_wrap     "$_t_fg_red"            "$_t_fg_off"        "$@"; }
	t_fg_green() {          util_wrap     "$_t_fg_green"          "$_t_fg_off"        "$@"; }
	t_fg_yellow() {         util_wrap     "$_t_fg_yellow"         "$_t_fg_off"        "$@"; }
	t_fg_blue() {           util_wrap     "$_t_fg_blue"           "$_t_fg_off"        "$@"; }
	t_fg_magenta() {        util_wrap     "$_t_fg_magenta"        "$_t_fg_off"        "$@"; }
	t_fg_cyan() {           util_wrap     "$_t_fg_cyan"           "$_t_fg_off"        "$@"; }
	t_fg_lightred() {       util_wrap     "$_t_fg_lightred"       "$_t_fg_off"        "$@"; }
	t_fg_lightgreen() {     util_wrap     "$_t_fg_lightgreen"     "$_t_fg_off"        "$@"; }
	t_fg_lightyellow() {    util_wrap     "$_t_fg_lightyellow"    "$_t_fg_off"        "$@"; }
	t_fg_lightblue() {      util_wrap     "$_t_fg_lightblue"      "$_t_fg_off"        "$@"; }
	t_fg_lightmagenta() {   util_wrap     "$_t_fg_lightmagenta"   "$_t_fg_off"        "$@"; }
	t_fg_lightcyan() {      util_wrap     "$_t_fg_lightcyan"      "$_t_fg_off"        "$@"; }
	t_fg_rainbow() {        util_fg_rainbow                                           "$@"; }

}

init_formatter() {
	if type "init_api_${FORMAT}" >/dev/null 2>&1; then
		init_api_${FORMAT}
	else
		init_api_terminal
	fi
	init_api_composeable
}


main() {
	init_formatter
}

main "$@"
